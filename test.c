#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <time.h>

#define CONST1 0x12345600
#define CONST2 0x42434400
#define NUMROWS 2

char encrypted_key[]   = {
        0x4b, 0xa6, 0x52, 0xd5, 0x91, 0x49, 0x32, 0x95,
        0x52, 0xbf, 0x41, 0xc6, 0x93, 0x83, 0xfa, 0x0d,
    };

char buffer[]   = {
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
    };

/// Compute a quick non-cryptographically secure hash for the passwords. Since no knowledge about
/// the correct password is exposed to the attacker, hash collisions are no concern.
void hash_password() {
    unsigned long hash;
    char tmp;
    
    for (int i = 0; i < NUMROWS; i++) {
        hash = 0;
        for (int j = 0; j < 8; j++) {
            hash += (buffer[(i * 8) + j] << (8 * j));
        }
        hash ^= hash << 13;
        hash ^= hash >> 17;
        hash ^= hash << 43;
        for (int j = 0; j < 8; j++) {
            buffer[(i * 8) + j] = ((hash >> (j * 8)) & 0xff);
        }
    }
}

/// This is basically a way-complicated memcmp to greatly mitigate a class of hardware based attacks
/// called sidechannels. 2 popular approaches attacks are power analysis and fault injections. 
///
/// PA attacks are performed by capturing power traces of the program during execution using an
/// oscilloscope. These are then analyzed (either manually or through statistical/ml-based analysis)
/// to learn about properties of the underlying code. This information can then be used to determine
/// cryptographical keys or in the case of a memcmp, the password that is being compared against.
/// This attack is extremely applicable in practice with very low-cost equipment, and is thus worth
/// mitigating against.
///
/// Fault injections rely on glitching the device during execution to make the processor skip
/// instructions. There are multiple ways to achieving this depending on the resources available to 
/// the attacker. The simplest method would be to simply cut power to the device at a critical point
/// during execution and then re-enabling it nano-seconds later. This can be used to trivially
/// bypass a simple 'if (key == 0xdeadbeef)' type check. More complex/expensive methods can include
/// electromagnetic pulses, lighting gates up with a sufficient photon intensity, or even lasers.
///
/// The below implementation uses several generally suggsted mitigations against these attacks as
/// described below.
///
/// 1. The entire operation is performed on set-size hashes of the password. This makes it harder
///    to learn anything of relevance about the actual password using power analysis.
/// 2. Additionally the function is extended with non-trivial values for important state. This is
///    done by preventing diff or tmpdiff to ever be all 1's or all 0's since these can often be
///    easily forced using fault injections. The lowest byte is set to 0 and used to accumulate the
///    difference into, which will result in a return of (CONST1 | CONST2). If some sidechannel
///    attack manages to flip a bit in any of the tmpdiff bits, this will be detected.
/// 3. While this code is not entirely branchless, the branch-operations are entirely duplicated
///    using decoy-inputs, which means that a power-trace should have almost the exact same result.
///    There exists a tiny difference between branch taken or branch not taken, but this is 
///    considerably harder to detect & interpret than the larger change of not duplicating code.
/// 4. On every iteration of the loop there is a 50% chance that we will execute a decoy operation
///    instead of the actual operation. This adds an extra hurdle for the attacker of having to
///    identify if their powertrace is currently in a decoy branch or in the operational.
/// 5. The operations are all done in a time-constant manner (apart from the intentional
///    randomization described above), which means that an attacker cannot easily identify the
///    password due to an early termination in the power-trace once an incorrect character is hit.
/// 6. Whenever the password is validated, we are looping through the arrays in a random order. This
///    makes it hard for an attacker to interpret the traces because they will differ greatly on
///    each run even without accounting the other mitigations.
/// 7. Finally a 'check' variable is maintained throughout the operations. If any important
///    operation is faulted during execution, the check variable has a high chance of detecting
///    this to stop any potential fault attacks.
///
/// Usually "security through obscurity" is frowned upon, however in the case of sidechannel
/// attacks, where the attacker has to often rely solely on power traces, introducing a lot of
/// additional noise and minimizing the noise generated by important operations can make it 
/// extremely hard (impossible without expensive equipment) for an attacker to make any progress on
/// a target.
int validate_pw(int n) {
    char decoy1[16];
    char decoy2[16];
    volatile int idx, decoy, tmpdiff, is_decoy;
    volatile int diff = 0;
    volatile int i = 0;
    volatile int rnd = rand() % (n - 1);
    volatile int check = 3;

    // Loop through the input in a random order
    while (i < n) {
        // Get a random index, wrap around once necessary
        idx = (i + rnd) % n;

        // Random chance to execute decoy operations instead of actual operation
        is_decoy = (rand() & 1);
        if (is_decoy) {
            check++;
            decoy   = ((CONST1 | decoy1[idx]) ^ (CONST2 | decoy2[idx]));
            tmpdiff = (CONST1 | CONST2);
        } else {
            check++;
            tmpdiff = ((CONST1 | buffer[idx]) ^ (CONST2 | encrypted_key[idx]));
            decoy   = (CONST1 | CONST2);
        }

        // Accumulate the actual difference
        diff = diff | tmpdiff;

        // Increment counter if this was not a decoy operation
        i += (is_decoy ^ 1);

        check--;
    }

    // Verify that the function executed correctly
    return check == 3 ? diff : 0;
}

int main() {
    // Initialize to non-zero so the authentication call can't trivially be bypassed by glitching
    // the function call instruction
    volatile int result = 7;
    volatile int result2 = 3;
    volatile int wait = 0;
    volatile int check;

    hash_password();

    srand(time(NULL));

    result = validate_pw(16);
    if (result == (CONST1 | CONST2)) {
        wait = rand() % 10;
        for (int i = 0; i < wait; i++) {
            check = check + 1;
        }

        // Verify that no fault has occured thus far
        if (check == wait) {
            // Recompute the result
            result2 = validate_pw(16);

            // Double check result, this time with a different logic that is slightly different
            // from the previous one
            if ((result2 & 0xff) == 0x0) {
                printf("unlocked");
                return 0;
            }
        }
    }
    printf("failed: %x", result);
    return 0;
}

